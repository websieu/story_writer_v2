# TODO - Story Writer v2 Improvement Plan

ÄÃ¢y lÃ  phÃ¢n tÃ­ch chi tiáº¿t vÃ  Ä‘á» xuáº¥t giáº£i phÃ¡p cho cÃ¡c váº¥n Ä‘á» trong há»‡ thá»‘ng Story Writer v2.

---

## 1. Sá»­a lá»—i láº¥y thÃ´ng tin entity vÃ  event tá»« batch 2 trá»Ÿ Ä‘i âœ… CRITICAL

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- PhÆ°Æ¡ng thá»©c `_entity_appears_in_chapter()` chá»‰ tráº£ vá» True náº¿u entity cÃ³ field `appear_in_chapters` vÃ  chapter_num náº±m trong Ä‘Ã³
- Entities Ä‘Æ°á»£c trÃ­ch xuáº¥t tá»« outline cá»§a batch 1 cÃ³ `appear_in_chapters` = [1,2,3,4,5]
- Khi viáº¿t batch 2 (chapters 6-10), cÃ¡c entities nÃ y bá»‹ lá»c ra vÃ¬ 6-10 khÃ´ng náº±m trong [1,2,3,4,5]
- Äiá»u nÃ y dáº«n Ä‘áº¿n **máº¥t thÃ´ng tin vá» nhÃ¢n váº­t, Ä‘á»‹a Ä‘iá»ƒm, items** Ä‘Ã£ xuáº¥t hiá»‡n á»Ÿ batch trÆ°á»›c

### NguyÃªn nhÃ¢n:
- **File:** `src/entity_manager.py`, line 370-384
- HÃ m `_entity_appears_in_chapter()` quÃ¡ strict, khÃ´ng cho phÃ©p entities tÃ¡i sá»­ dá»¥ng qua cÃ¡c batch
- **File:** `main.py`, line 224-242
- `_prepare_batch_context()` khÃ´ng láº¥y Ä‘áº§y Ä‘á»§ entities tá»« batch trÆ°á»›c

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 1.1. Cáº­p nháº­t logic appear_in_chapters tá»± Ä‘á»™ng
Sau khi trÃ­ch xuáº¥t entities tá»« chapter, tá»± Ä‘á»™ng cáº­p nháº­t `appear_in_chapters` cho cÃ¡c entities Ä‘Ã£ cÃ³:

```python
# Trong EntityManager
def _update_entity_appearances(self, chapter_content: str, chapter_num: int):
    """Tá»± Ä‘á»™ng cáº­p nháº­t appear_in_chapters dá»±a trÃªn chapter content"""
    content_lower = chapter_content.lower()
    
    for category, entities in self.entities.items():
        for entity in entities:
            name = entity.get('name', '')
            if name and name.lower() in content_lower:
                appear_in = entity.get('appear_in_chapters', [])
                if chapter_num not in appear_in:
                    appear_in.append(chapter_num)
                    appear_in.sort()
                    entity['appear_in_chapters'] = appear_in
```

#### 1.2. Cáº£i thiá»‡n get_relevant_entities
Má»Ÿ rá»™ng logic láº¥y entities Ä‘á»ƒ bao gá»“m:
- Entities xuáº¥t hiá»‡n trong 2-3 chapters gáº§n nháº¥t
- Main characters (xuáº¥t hiá»‡n >= 5 chapters)
- Entities Ä‘Æ°á»£c Ä‘á» cáº­p trong outline

```python
def get_relevant_entities(self, chapter_outline: Dict[str, Any], max_entities: int = 20):
    relevant = []
    chapter_num = chapter_outline.get('chapter_number', 0)
    
    # 1. Entities trong chapter hiá»‡n táº¡i
    # 2. Entities trong 2-3 chapters gáº§n nháº¥t
    recent_chapters = [chapter_num, chapter_num-1, chapter_num-2]
    for ch in recent_chapters:
        if ch > 0:
            relevant.extend(self._get_entities_by_chapter(ch))
    
    # 3. Main characters/entities (frequent appearances)
    frequent = self.get_frequently_used_entities(min_chapters=3)
    relevant.extend(frequent)
    
    # 4. Deduplicate vÃ  limit
    return self._deduplicate_entities(relevant)[:max_entities]
```

#### 1.3. ThÃªm phÆ°Æ¡ng thá»©c get_frequently_used_entities
```python
def get_frequently_used_entities(self, min_chapters: int = 3) -> List[Dict[str, Any]]:
    """Láº¥y entities xuáº¥t hiá»‡n thÆ°á»ng xuyÃªn (main characters, important items)"""
    result = []
    for category, entities in self.entities.items():
        for entity in entities:
            appear_in = entity.get('appear_in_chapters', [])
            if len(appear_in) >= min_chapters:
                result.append({**entity, 'category': category})
    return result
```

#### 1.4. Cáº£i thiá»‡n _prepare_batch_context
```python
def _prepare_batch_context(self, batch_num: int, user_suggestions: Optional[str] = None):
    # ... existing code ...
    
    # ThÃªm: Main entities (xuáº¥t hiá»‡n >= 3 chapters)
    frequent_entities = self.entity_manager.get_frequently_used_entities(min_chapters=3)
    
    # ThÃªm: Entities tá»« 5 chapters gáº§n nháº¥t  
    prev_batch = batch_num - 1
    start_ch = max(1, (prev_batch - 1) * 5 + 1)
    end_ch = prev_batch * 5
    recent_entities = []
    for ch in range(start_ch, end_ch + 1):
        recent_entities.extend(self.entity_manager.get_entities_by_chapter(ch))
    
    return {
        # ... existing ...
        'frequent_entities': frequent_entities,
        'recent_entities': recent_entities
    }
```

---

## 2. Tá»‘i Æ°u cÃ¡ch láº¥y entity vÃ  event liÃªn quan Ä‘áº¿n chapter âš¡

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- Viá»‡c lá»c entities quÃ¡ háº¡n cháº¿, thiáº¿u context
- Events khÃ´ng Ä‘Æ°á»£c lá»c theo Ä‘á»™ quan trá»ng vÃ  thá»i gian
- Entities/events quan trá»ng cÃ³ thá»ƒ bá»‹ bá» qua

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 2.1. ThÃªm scoring system cho entities
```python
def score_entity_relevance(self, entity: Dict[str, Any], chapter_num: int, 
                          character_names: List[str]) -> float:
    """TÃ­nh Ä‘iá»ƒm liÃªn quan cá»§a entity vá»›i chapter hiá»‡n táº¡i"""
    score = 0.0
    
    # Entity xuáº¥t hiá»‡n trong chapter nÃ y: +10
    if self._entity_appears_in_chapter(entity, chapter_num):
        score += 10.0
    
    # Entity xuáº¥t hiá»‡n trong 1-2 chapters gáº§n: +5
    recent = [chapter_num - 1, chapter_num - 2]
    if any(self._entity_appears_in_chapter(entity, ch) for ch in recent if ch > 0):
        score += 5.0
    
    # Entity liÃªn quan Ä‘áº¿n nhÃ¢n váº­t chÃ­nh: +3
    associated = entity.get('associated_characters', [])
    if any(char in associated for char in character_names):
        score += 3.0
    
    # Main character (xuáº¥t hiá»‡n >= 5 chapters): +8
    if len(entity.get('appear_in_chapters', [])) >= 5:
        score += 8.0
    
    # Important items/techniques: +2
    if entity.get('importance', 0) > 0.7:
        score += 2.0
    
    return score
```

#### 2.2. Events vá»›i time decay
```python
def get_events_by_entities(self, entity_names: List[str], current_chapter: int,
                           max_events: int = 10) -> List[Dict[str, Any]]:
    """Láº¥y events vá»›i time decay - events gáº§n Ä‘Ã¢y quan trá»ng hÆ¡n"""
    related_events = []
    
    for event in self.events:
        # Check involvement
        involved = self._is_entity_involved(event, entity_names)
        
        if involved:
            importance = event.get('importance', 0.5)
            event_chapter = event.get('chapter', 1)
            
            # Time decay: events cÃ ng gáº§n cÃ ng quan trá»ng
            chapters_ago = current_chapter - event_chapter
            time_decay = 1.0 / (1.0 + chapters_ago * 0.1)
            
            relevance_score = importance * time_decay
            event['relevance_score'] = relevance_score
            related_events.append(event)
    
    related_events.sort(key=lambda x: x.get('relevance_score', 0), reverse=True)
    return related_events[:max_events]
```

#### 2.3. Cache Ä‘á»ƒ giáº£m tÃ­nh toÃ¡n
```python
class EntityManager:
    def __init__(self, ...):
        self._entity_cache = {}  # chapter_num -> relevant_entities
        self._cache_ttl = 5
    
    def get_relevant_entities_cached(self, chapter_outline, max_entities=20):
        chapter_num = chapter_outline.get('chapter_number', 0)
        
        if chapter_num in self._entity_cache:
            return self._entity_cache[chapter_num]
        
        relevant = self.get_relevant_entities(chapter_outline, max_entities)
        self._entity_cache[chapter_num] = relevant
        
        # Clean old cache
        old = [k for k in self._entity_cache if k < chapter_num - self._cache_ttl]
        for k in old:
            del self._entity_cache[k]
        
        return relevant
```

---

## 3. ÄÃ¡nh giÃ¡ vÃ  Ä‘iá»u chá»‰nh logic cho truyá»‡n 300 chÆ°Æ¡ng ğŸ“š

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- Há»‡ thá»‘ng thiáº¿t káº¿ cho truyá»‡n ngáº¯n (5-50 chÆ°Æ¡ng)
- Conflict timeline khÃ´ng phÃ¹ há»£p vá»›i 300 chÆ°Æ¡ng
- Super summary sáº½ quÃ¡ dÃ i
- Entity list phÃ¬nh to (hÃ ng trÄƒm entities)

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 3.1. Äiá»u chá»‰nh conflict timeline
```python
CONFLICT_TIMELINES_300_CHAPTERS = {
    'immediate': 1,      # 1 chapter
    'batch': 5,          # 5 chapters (1 batch)
    'arc': 20,           # 20 chapters (1 arc, ~4 batches)
    'volume': 50,        # 50 chapters (1 volume)
    'saga': 150,         # 150 chapters (ná»­a truyá»‡n)
    'epic': 300          # ToÃ n bá»™ truyá»‡n
}
```

#### 3.2. Hierarchical summary system
```python
# Thay vÃ¬ 1 super_summary cho 300 chapters:
summaries = {
    'current_arc_summary': "20 chapters gáº§n nháº¥t (400-500 tá»«)",
    'current_volume_summary': "Volume hiá»‡n táº¡i (600-800 tá»«)",
    'story_overview': "ToÃ n bá»™ truyá»‡n (800-1000 tá»«)",
    'recent_chapters': ["5 chapters gáº§n nháº¥t"]
}
```

#### 3.3. Entity importance decay
```python
def calculate_entity_importance(self, entity: Dict, current_chapter: int) -> float:
    """Importance giáº£m dáº§n theo thá»i gian khÃ´ng xuáº¥t hiá»‡n"""
    appear_in = entity.get('appear_in_chapters', [])
    if not appear_in:
        return 0.0
    
    last_chapter = max(appear_in)
    chapters_since = current_chapter - last_chapter
    
    frequency = len(appear_in)
    base_importance = min(1.0, frequency / 10.0)
    
    # Decay náº¿u khÃ´ng xuáº¥t hiá»‡n >20 chapters
    if chapters_since > 20:
        decay = 0.5 ** (chapters_since / 20)
        return base_importance * decay
    
    return base_importance
```

#### 3.4. Arc-based structure
```python
class ArcManager:
    """Quáº£n lÃ½ story arcs cho truyá»‡n dÃ i"""
    
    def __init__(self, chapters_per_arc=20):
        self.chapters_per_arc = chapters_per_arc
        self.arcs = []
    
    def create_arc(self, arc_num: int, theme: str, main_conflict: str):
        arc = {
            'arc_number': arc_num,
            'start_chapter': (arc_num - 1) * self.chapters_per_arc + 1,
            'end_chapter': arc_num * self.chapters_per_arc,
            'theme': theme,
            'main_conflict': main_conflict,
            'status': 'planning'
        }
        self.arcs.append(arc)
        return arc
```

---

## 4. Äiá»u phá»‘i nhá»‹p truyá»‡n vÃ  phong cÃ¡ch viáº¿t ğŸ­

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- KhÃ´ng cÃ³ cÆ¡ cháº¿ Ä‘iá»u chá»‰nh pacing vÃ  tone
- Táº¥t cáº£ chapters cÃ³ cÃ¹ng style
- KhÃ´ng cÃ³ variation, gÃ¢y nhÃ m chÃ¡n

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 4.1. Pacing vÃ  Tone configuration
```yaml
# Trong config.yaml
story_pacing:
  pacing_cycle:
    - {batch: 1, pace: "slow", tone: "mysterious", focus: "world_building"}
    - {batch: 2, pace: "medium", tone: "adventurous", focus: "character_development"}
    - {batch: 3, pace: "fast", tone: "intense", focus: "action"}
    - {batch: 4, pace: "slow", tone: "emotional", focus: "resolution"}
    - {batch: 5, pace: "medium", tone: "suspenseful", focus: "plot_twist"}
  
  pace_definitions:
    slow: "MÃ´ táº£ chi tiáº¿t, ná»™i tÃ¢m nhÃ¢n váº­t, xÃ¢y dá»±ng khÃ´ng khÃ­"
    medium: "CÃ¢n báº±ng hÃ nh Ä‘á»™ng vÃ  mÃ´ táº£, tiáº¿t táº¥u Ä‘á»u"
    fast: "Nhiá»u hÃ nh Ä‘á»™ng, Ä‘á»‘i thoáº¡i nhanh, Ã­t mÃ´ táº£"
  
  tone_definitions:
    mysterious: "BÃ­ áº©n, há»“i há»™p, nhiá»u foreshadowing"
    adventurous: "KhÃ¡m phÃ¡, gáº·p nhÃ¢n váº­t má»›i"
    intense: "CÄƒng tháº³ng, xung Ä‘á»™t gay gáº¯t"
    emotional: "Táº­p trung cáº£m xÃºc, má»‘i quan há»‡"
    humorous: "HÃ i hÆ°á»›c, nháº¹ nhÃ ng"
    dark: "Bi ká»‹ch, tÃ n khá»‘c"
```

#### 4.2. PacingManager
```python
class PacingManager:
    """Quáº£n lÃ½ pacing vÃ  tone"""
    
    def get_batch_style(self, batch_num: int) -> Dict[str, str]:
        """Láº¥y style cho batch dá»±a trÃªn cycle"""
        idx = (batch_num - 1) % len(self.pacing_cycle)
        return self.pacing_cycle[idx]
    
    def generate_style_prompt(self, batch_num: int) -> str:
        """Táº¡o prompt Ä‘iá»u chá»‰nh style"""
        style = self.get_batch_style(batch_num)
        
        prompt = f"""
**PHONG CÃCH VIáº¾T CHO BATCH {batch_num}:**
- Nhá»‹p Ä‘á»™: {style['pace'].upper()}
- Tone: {style['tone'].upper()}
- Trá»ng tÃ¢m: {style['focus']}
"""
        
        if style['pace'] == 'fast':
            prompt += "- Nhiá»u hÃ nh Ä‘á»™ng, Ã­t mÃ´ táº£ dÃ i\n"
        elif style['pace'] == 'slow':
            prompt += "- MÃ´ táº£ chi tiáº¿t, phÃ¡t triá»ƒn tá»« tá»«\n"
        
        return prompt
```

#### 4.3. VillainManager
```python
class VillainManager:
    """Quáº£n lÃ½ tiáº¿n trÃ¬nh tiÃªu diá»‡t tiá»ƒu nhÃ¢n"""
    
    def plan_villain_defeat(self, current_chapter: int) -> List[str]:
        """Villains xuáº¥t hiá»‡n lÃ¢u (>20 chapters) nÃªn Ä‘Æ°á»£c defeat"""
        to_defeat = []
        for villain in self.villains:
            if villain['status'] == 'active':
                chapters_active = current_chapter - villain['introduction_chapter']
                if chapters_active > 20:
                    to_defeat.append(villain['name'])
        return to_defeat
```

---

## 5. Kiá»ƒm tra vÃ  quáº£n lÃ½ character status ğŸ‘¥

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- KhÃ´ng cÃ³ tracking sá»‘ lÆ°á»£ng characters
- KhÃ´ng biáº¿t character nÃ o active/inactive
- Dá»… bá»‹ character bloat

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 5.1. CharacterManager
```python
class CharacterManager:
    """Quáº£n lÃ½ characters"""
    
    def get_character_stats(self, current_chapter: int) -> Dict[str, Any]:
        """Thá»‘ng kÃª characters"""
        characters = self.entity_manager.entities.get('characters', [])
        
        stats = {
            'total': len(characters),
            'main': [],           # Xuáº¥t hiá»‡n >= 10 chapters
            'supporting': [],     # 3-9 chapters
            'minor': [],          # 1-2 chapters
            'inactive': [],       # KhÃ´ng xuáº¥t hiá»‡n >20 chapters
            'recent': []          # Xuáº¥t hiá»‡n trong 5 chapters gáº§n
        }
        
        for char in characters:
            appear_in = char.get('appear_in_chapters', [])
            name = char.get('name', 'Unknown')
            frequency = len(appear_in)
            
            if frequency >= 10:
                stats['main'].append(name)
            elif frequency >= 3:
                stats['supporting'].append(name)
            else:
                stats['minor'].append(name)
            
            if appear_in:
                last = max(appear_in)
                if current_chapter - last > 20:
                    stats['inactive'].append(name)
                elif last > current_chapter - 5:
                    stats['recent'].append(name)
        
        return stats
    
    def should_introduce_new_character(self, current_chapter: int) -> bool:
        """Quyáº¿t Ä‘á»‹nh cÃ³ nÃªn giá»›i thiá»‡u character má»›i"""
        stats = self.get_character_stats(current_chapter)
        
        # KhÃ´ng náº¿u quÃ¡ nhiá»u active (>15)
        active = len(stats['main']) + len(stats['supporting'])
        if active > 15:
            return False
        
        # KhÃ´ng náº¿u vá»«a giá»›i thiá»‡u nhiá»u trong 3 chapters
        if len(stats['recent']) > 3:
            return False
        
        return True
```

#### 5.2. Character guidelines trong prompt
```python
def add_character_guidelines(self, chapter_num: int, prompt: str) -> str:
    stats = self.char_mgr.get_character_stats(chapter_num)
    
    guidelines = f"""
**QUáº¢N LÃ NHÃ‚N Váº¬T:**
- Tá»•ng: {stats['total']}
- ChÃ­nh: {len(stats['main'])}
- Phá»¥: {len(stats['supporting'])}
- KhÃ´ng hoáº¡t Ä‘á»™ng: {len(stats['inactive'])}

**HÆ°á»›ng dáº«n:**
"""
    
    if not self.char_mgr.should_introduce_new_character(chapter_num):
        guidelines += "- KHÃ”NG giá»›i thiá»‡u nhÃ¢n váº­t má»›i (Ä‘Ã£ Ä‘á»§)\n"
    
    reintroduce = self.char_mgr.suggest_character_reintroduction(chapter_num)
    if reintroduce:
        guidelines += f"- ÄÆ°a trá»Ÿ láº¡i: {', '.join(reintroduce)}\n"
    
    return prompt + guidelines
```

---

## 6. XÃ¡c Ä‘á»‹nh Ä‘iá»ƒm káº¿t truyá»‡n (open ending) ğŸ¬

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- KhÃ´ng cÃ³ planning cho ending
- KhÃ´ng biáº¿t khi nÃ o hÆ°á»›ng tá»›i káº¿t thÃºc

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 6.1. Ending configuration
```yaml
# config.yaml
story_structure:
  total_chapters: 300
  
  acts:
    act1_setup:
      chapters: [1, 60]
      description: "Giá»›i thiá»‡u tháº¿ giá»›i, nhÃ¢n váº­t"
    act2_rising:
      chapters: [61, 180]
      description: "PhÃ¡t triá»ƒn conflicts, MC máº¡nh hÆ¡n"
    act3_climax:
      chapters: [181, 270]
      description: "Äá»‘i Ä‘áº§u big boss"
    act4_resolution:
      chapters: [271, 300]
      description: "Giáº£i quyáº¿t subplots, ending"
  
  ending_type: "open"  # "closed", "open", "cliffhanger"
```

#### 6.2. EndingManager
```python
class EndingManager:
    """Quáº£n lÃ½ progression tá»›i ending"""
    
    def get_current_act(self, chapter_num: int) -> str:
        for act_name, act_info in self.acts.items():
            start, end = act_info['chapters']
            if start <= chapter_num <= end:
                return act_name
        return 'unknown'
    
    def get_ending_guidance(self, chapter_num: int) -> str:
        progress = chapter_num / self.total_chapters
        
        if progress < 0.6:
            return "Giai Ä‘oáº¡n phÃ¡t triá»ƒn, thoáº£i mÃ¡i má»Ÿ subplots má»›i"
        elif progress < 0.9:
            return "HÆ°á»›ng tá»›i giáº£i quyáº¿t main conflicts, trÃ¡nh má»Ÿ subplots phá»©c táº¡p"
        else:
            guidance = "GIAI ÄOáº N ENDING!\n"
            guidance += "- Æ¯u tiÃªn giáº£i quyáº¿t conflicts\n"
            guidance += "- KHÃ”NG má»Ÿ subplots má»›i\n"
            if self.ending_type == 'open':
                guidance += "- Giáº£i quyáº¿t main conflict, Ä‘á»ƒ ngá» possibilities\n"
            return guidance
```

---

## 7. Kiá»ƒm tra vÃ  sá»­a lá»—i tÃªn entity chung chung ğŸ”

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- Entities cÃ³ tÃªn chung chung: "Thanh gÆ°Æ¡m", "Äá»™ng"
- KhÃ³ phÃ¢n biá»‡t vÃ  track

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 7.1. EntityNameValidator
```python
class EntityNameValidator:
    """Validate entity names"""
    
    GENERIC_NAMES = {
        'items': ['thanh gÆ°Æ¡m', 'kiáº¿m', 'Ã¡o', 'bÃ¹a'],
        'locations': ['Ä‘á»™ng', 'thung lÅ©ng', 'nÃºi', 'rá»«ng'],
        'techniques': ['chiÃªu', 'thá»©c', 'cÃ´ng phÃ¡p']
    }
    
    def is_name_too_generic(self, name: str, category: str) -> bool:
        name_lower = name.lower().strip()
        
        # Too short
        if len(name_lower) < 3:
            return True
        
        # In generic list
        generic_list = self.GENERIC_NAMES.get(category, [])
        if name_lower in generic_list:
            return True
        
        return False
    
    def suggest_improvement(self, name: str, category: str) -> str:
        if category == 'items':
            return "ThÃªm tÃ­nh tá»«: 'BÄƒng Há»a Kiáº¿m', 'Huyá»n ThiÃªn Báº£o GiÃ¡p'"
        elif category == 'locations':
            return "ThÃªm tÃªn riÃªng: 'Thanh VÃ¢n Äá»™ng', 'ThiÃªn TrÆ°á»£ng Thung'"
        return "ThÃªm tÃ­nh tá»« hoáº·c tÃªn riÃªng"
```

#### 7.2. ThÃªm vÃ o extraction prompt
```python
prompt += """
**QUY Táº®C Äáº¶T TÃŠN ENTITY:**

âŒ SAI: "Thanh gÆ°Æ¡m", "Äá»™ng", "ChiÃªu thá»©c"
âœ… ÄÃšNG: "BÄƒng Há»a Tháº§n Kiáº¿m", "Thanh VÃ¢n Äá»™ng", "Cá»­u ThiÃªn Huyá»n Ná»¯ CÃ´ng"

**Items:** ThÃªm tÃ­nh tá»« Ä‘áº·c biá»‡t (BÄƒng, Há»a, ThiÃªn...)
**Locations:** TÃªn Ä‘á»‹a danh cá»¥ thá»ƒ
**Techniques:** TÃªn cÃ´ng phÃ¡p Ä‘áº§y Ä‘á»§
**Characters:** Full name HÃ¡n Viá»‡t (2-3 chá»¯)

Náº¿u khÃ´ng cÃ³ tÃªn riÃªng rÃµ rÃ ng, KHÃ”NG trÃ­ch xuáº¥t.
"""
```

#### 7.3. Post-processing validation
```python
def _validate_and_filter_entities(self, entities: Dict, validator) -> Dict:
    """Lá»c entities cÃ³ tÃªn chung chung"""
    filtered = {}
    
    for category, entity_list in entities.items():
        filtered[category] = []
        
        for entity in entity_list:
            name = entity.get('name', '')
            
            if validator.is_name_too_generic(name, category):
                self.logger.warning(
                    f"Rejected generic: '{name}' ({category}). "
                    f"Suggestion: {validator.suggest_improvement(name, category)}"
                )
                continue
            
            filtered[category].append(entity)
    
    return filtered
```

---

## 8. Kiá»ƒm tra vÃ  cáº£i thiá»‡n logic conflict checking âš”ï¸

### Váº¥n Ä‘á» hiá»‡n táº¡i:
- Conflict resolution khÃ´ng track cháº·t cháº½
- KhÃ´ng kiá»ƒm tra conflict cÃ³ thá»±c sá»± resolved
- Timeline khÃ´ng Ä‘Æ°á»£c enforce

### Giáº£i phÃ¡p Ä‘á» xuáº¥t:

#### 8.1. ConflictValidator
```python
class ConflictValidator:
    """Validate conflicts vÃ  track resolution"""
    
    def validate_timeline(self, conflict: Dict, current_chapter: int) -> Dict:
        """Kiá»ƒm tra conflict cÃ³ vi pháº¡m timeline khÃ´ng"""
        introduced = conflict.get('introduced_in_chapter', 1)
        timeline = conflict.get('timeline', 'batch')
        status = conflict.get('status', 'active')
        
        chapters_elapsed = current_chapter - introduced
        
        timeline_limits = {
            'immediate': 1, 'batch': 5, 'short_term': 10,
            'medium_term': 30, 'long_term': 100, 'epic': 300
        }
        
        limit = timeline_limits.get(timeline, 10)
        
        validation = {
            'conflict_id': conflict.get('id', ''),
            'is_overdue': status == 'active' and chapters_elapsed > limit,
            'warning': None
        }
        
        if validation['is_overdue']:
            validation['warning'] = (
                f"Conflict overdue: '{conflict.get('description', '')}' "
                f"(ch.{introduced}, timeline: {timeline}={limit}ch, now: ch.{current_chapter})"
            )
        
        return validation
```

#### 8.2. Conflict resolution verification
```python
def verify_resolution(self, content: str, conflict_id: str, desc: str) -> bool:
    """Verify conflict thá»±c sá»± resolved trong chapter"""
    keywords = ['giáº£i quyáº¿t', 'káº¿t thÃºc', 'chiáº¿n tháº¯ng', 'Ä‘Ã¡nh báº¡i']
    
    content_lower = content.lower()
    
    if desc.lower() not in content_lower:
        return False
    
    return any(kw in content_lower for kw in keywords)

def extract_conflicts(self, chapter_content: str, chapter_num: int):
    # ... existing ...
    
    # Verify expected resolutions
    outline = self._get_chapter_outline(chapter_num)
    if outline:
        expected = outline.get('expected_conflict_updates', {})
        
        for conf_id, expected_status in expected.items():
            if expected_status == 'resolved':
                conflict = self._find_conflict(conf_id)
                if conflict:
                    verified = self.verify_resolution(
                        chapter_content, conf_id, conflict.get('description', '')
                    )
                    
                    if not verified:
                        self.logger.warning(
                            f"Ch{chapter_num}: Conflict {conf_id} expected resolved "
                            f"but couldn't verify"
                        )
```

#### 8.3. Conflict dependency tracking
```python
class ConflictDependencyTracker:
    """Track dependencies giá»¯a conflicts"""
    
    def __init__(self):
        self.dependencies = {}  # parent -> [children]
    
    def can_resolve(self, conflict_id: str, resolved: List[str]) -> bool:
        """Kiá»ƒm tra conflict cÃ³ thá»ƒ resolve (dependencies Ä‘Ã£ resolve?)"""
        parents = [p for p, children in self.dependencies.items() 
                  if conflict_id in children]
        return all(p in resolved for p in parents)
```

---

## 9. Tá»•ng káº¿t vÃ  roadmap triá»ƒn khai ğŸš€

### Thá»© tá»± Æ°u tiÃªn:

**Phase 1 - Critical Fixes (1-2 tuáº§n):**
1. âœ… Item 1: Sá»­a lá»—i batch 2+ khÃ´ng láº¥y entities/events
2. âœ… Item 2: Entity/event relevance scoring
3. âœ… Item 7: Entity name validation

**Phase 2 - Core Improvements (2-3 tuáº§n):**
4. Item 5: CharacterManager vÃ  tracking
5. Item 8: ConflictValidator
6. Item 3: Äiá»u chá»‰nh cho 300 chapters

**Phase 3 - Advanced Features (3-4 tuáº§n):**
7. Item 4: PacingManager vÃ  style control
8. Item 6: EndingManager
9. Arc-based structure
10. Conflict dependencies

### Testing checklist:
- [ ] Batch 1 generation (baseline)
- [ ] Batch 2 láº¥y Ä‘Æ°á»£c entities tá»« batch 1
- [ ] Batch 3-4 vá»›i entity persistence
- [ ] Character bloat prevention
- [ ] Conflict timeline enforcement
- [ ] Ending guidance á»Ÿ chapter 270+
- [ ] Pacing variation

### Monitoring:
- Entity retrieval success rate
- Character count over time
- Conflict resolution rate
- Super summary length growth

---

## Implementation Notes

### Backward Compatibility
- Táº¥t cáº£ thay Ä‘á»•i pháº£i backward compatible
- ThÃªm feature flags Ä‘á»ƒ enable/disable features
- Existing data structures khÃ´ng bá»‹ break

### Code Quality
- Document ká»¹ trong code
- Viáº¿t unit tests cho validators
- Type hints cho táº¥t cáº£ methods má»›i

### Configuration
- ThÃªm vÃ o config.yaml vá»›i defaults há»£p lÃ½
- Cho phÃ©p override qua command line args
- Validate config khi load

### Performance
- Cache káº¿t quáº£ tÃ­nh toÃ¡n entities/events
- Lazy load data khi cáº§n
- Profile Ä‘á»ƒ tÃ¬m bottlenecks

---

**TÃ i liá»‡u nÃ y sáº½ Ä‘Æ°á»£c cáº­p nháº­t khi implement tá»«ng phase.**
